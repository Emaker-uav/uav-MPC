function Fu = uavNMPC(X_states,X_des,Q,R,N,dT_MPC)
tic
global u0;
X_ref = generateReference(X_states,X_des,N);
nonlcon = @(u) stateConstraints(u, X_states, N, dT_MPC, v_max);

fun = @(u)costFunction(u,X_states,X_ref, Q, R, N,dT_MPC);
options = optimoptions('fmincon','Display','iter','Algorithm','sqp');
A = diag([1,1,1,1,1,1]);
b = [[];
     [];
     [];
     0.5;
     0.5;
     0.5];
lb = [-30;
      -30;
      -180;
      0;
      -30;
      -30;
      -180;
      0;
      -30;
      -30;
      -180;
      0;
      -30;
      -30;
      -180;
      0;
      -30;
      -30;
      -180;
      0;];
ub = [30;
      30;
      180;
      25;
      30;
      30;
      180;
      25;
      30;
      30;
      180;
      25;
      30;
      30;
      180;
      25;
      30;
      30;
      180;
      25];
Fu = fmincon(fun,u0,A,b,[],[],lb,ub,[],options);
u0 = Fu;
toc
end
%% 
function x_ref = generateReference(x,x_des,h)
    x_ref = zeros(size(x,1), h);
    for i = 1 : size(x,1)
        x_ref(i,:) = linspace(x(i), x_des(i), h);
    end
end

function [c, ceq] = stateConstraints(u, X_states, N, dT_MPC, v_max)
    % 初始化约束
    c = [];
    ceq = [];
    
    % 初始状态
    X_current = X_states;
    
    % 循环预测时域
    for k = 1:N
        % 当前输入
        u_k = u(4*(k-1)+1 : 4*k);
        
        % 根据系统动力学更新状态
        derx = uavDynamics(X_current, u_k);
        X_current = X_current + dT_MPC * derx;
        % 提取速度 (vx, vy, vz)
        vx = X_current(4);
        vy = X_current(5);
        vz = X_current(6);
        
        % 添加速度约束：-v_max <= v <= v_max
        c = [c; vx - v_max; -vx - v_max; vy - v_max; -vy - v_max; vz - v_max; -vz - v_max];
    end
end
